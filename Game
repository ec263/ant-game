
import java.awt.Point;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;


/**
 *
 * @author Zachary Hoad
 */
public class Game {
    
    private Map map;
    private Map cleanMap;
    private ArrayList<Ant> ants;
    private ArrayList<Instruction> redBrain;
    private ArrayList<Instruction> blackBrain;
    private Statistics statistics;
    
    
    public Game(Map map, ArrayList<Instruction> redBrain, ArrayList<Instruction> blackBrain){
        this.map=map;
        cleanMap=map;
        this.redBrain=redBrain;
        this.blackBrain=blackBrain;
        statistics=new Statistics();
        initialiseRandomint(new BigInteger(""+System.currentTimeMillis()));
        
        statistics.mapFood=1375; //Tournament legal worlds must have this much food
        statistics.blackAnts=127; //And this many ants
        statistics.redAnts=127;
        
        ants=new ArrayList();
        
        int h=0;
        do{
            int w=0;
            do{
                Point pos=new Point(h, w);
                if (anthillAt(pos, Colour.RED)){
                    try {
                        Ant a = new Ant(Colour.RED, 0, 0, 0, false, pos);
                        ants.add(a);
                    } catch (Exception ex) {
                        Logger.getLogger(Game.class.getName()).log(Level.SEVERE, null, ex);//Should never happen
                    }
                }
                if (anthillAt(pos, Colour.BLACK)){
                    try {
                        Ant a=new Ant(Colour.BLACK, 0, 0, 0, false, pos);
                        ants.add(a);
                    } catch (Exception ex) {
                        Logger.getLogger(Game.class.getName()).log(Level.SEVERE, null, ex);
                    }//Should never happen
                }
                w++;
            } while(w<map.width&&ants.size()<254);
            h++;
        } while(h<map.height&&ants.size()<254);
        
        if (ants.size()!=254){
            System.out.println("URGENT PROBLEM! Look in Game constructor");
        }
        
        
    }
    
    public Game(ArrayList<Instruction> redBrain, ArrayList<Instruction> blackBrain){
        this.redBrain=redBrain;
        this.blackBrain=blackBrain;
    }
    
    public Game newMap(Map map){
        return new Game(map, redBrain, blackBrain);
    }
    
    public Game swapSides(){
        return new Game(cleanMap, blackBrain, redBrain);
    }
    
    public Statistics getStatistics(){
        return statistics;
    }
    
    public Map getMap(){
        return map;
    }
    
    public ArrayList<Ant> getAnts(){
        return ants;
    }
    
    public void nextTurn(){
        for (int i=0; i<254; i++){
            step(i);
        }
    }

    private void step(int id){
        if (antIsAlive(id)){
            Point point = findAnt(id);
            Ant a = ants.get(id);
            if (resting(a)>0){
                setResting(a, resting(a)-1);
            } else {
                Instruction i = getInstruction(colour(a), state(a));
                if(i instanceof Sense){
                    Sense s =(Sense)i;
                    Point pp=sensedCell(point, direction(a), s.sensedir);
                    if (cellMatches(pp, s.cond, colour(a))){
                        setState(a, s.st1);
                    } else {
                        setState(a, s.st2);
                    }
                }
                if (i instanceof Mark){
                    Mark m = (Mark)i;
                    setMarkerAt(point, colour(a), m.i);
                    setState(a, m.st);
                }
                if (i instanceof Unmark){
                    Unmark u =(Unmark)i;
                    clearMarkerAt(point, colour(a), u.i);
                    setState(a, u.st);
                }
                if (i instanceof PickUp){
                    PickUp p = (PickUp)i;
                    if (hasFood(a)||foodAt(point)==0){
                        setState(a, p.st2);
                    } else {
                        setFoodAt(point, foodAt(point)-1);
                        setHasFood(a, true);
                        setState(a, p.st1);
                        statistics.mapFood--;
                        if (anthillAt(point, Colour.RED)){
                            statistics.redHillFood--;
                        }
                        if (anthillAt(point, Colour.BLACK)){
                            statistics.blackHillFood--;
                        }
                    }
                }
                if (i instanceof Drop){
                    Drop d = (Drop)i;
                    if (hasFood(a)){
                        setFoodAt(point, foodAt(point)+1);
                        setHasFood(a, false);
                        statistics.mapFood++;
                        if (anthillAt(point, Colour.RED)){
                            statistics.redHillFood++;
                        }
                        if (anthillAt(point, Colour.BLACK)){
                            statistics.blackHillFood++;
                        }
                    }
                    setState(a, d.st);
                }
                if (i instanceof Turn){
                    Turn t = (Turn)i;
                    setDirection(a, turn(t.lr, direction(a)));
                    setState(a, t.st);
                }
                if (i instanceof Move){
                    Move m = (Move)i;
                    Point newp = adjacentCell(point, direction(a));
                    if (rocky(newp)||someAntIsAt(newp)){
                        setState(a, m.st2);
                    } else {
                        clearAntAt(point);
                        setAntAt(newp, a);
                        setState(a, m.st1);
                        setResting(a, 14);
                        checkForSurroundedAnts(newp);
                    }
                }
                if (i instanceof Flip){
                    Flip f =(Flip)i;
                    if (randomint(f.n)==0){
                        setState(a, f.st1);
                    } else {
                        setState(a, f.st2);
                    }
                }
            }
        }
    }
    
    private int turn(leftOrRight lr, int dir){
        if (lr==leftOrRight.LEFT){
            return (dir+5)%6;
        }
        if (lr==leftOrRight.RIGHT){
            return(dir+1)%6;
        }
        return -1; //Shouldn't happen
    }
    
    private Point sensedCell(Point p, int d, Direction sd){
        if (sd==Direction.HERE){
            return p;
        }
        if (sd==Direction.AHEAD){
            return adjacentCell(p, d);
        }
        if (sd==Direction.LEFTAHEAD){
            return adjacentCell(p, turn(leftOrRight.LEFT, d));
        }
        if (sd==Direction.RIGHTAHEAD){
            return adjacentCell(p, turn(leftOrRight.RIGHT, d));
        }
        return null;
    }
    
    private Point adjacentCell(Point p, int d){
        switch (d){
          case 0: return new Point(p.x+1, p.y);
          case 1: if (even(p.y)){ return new Point(p.x, p.y+1);} else {return new Point(p.x+1, p.y+1);}
          case 2: if (even(p.y)) {return new Point(p.x-1, p.y+1); } else { return new Point(p.x, p.y+1);}
          case 3: return new Point(p.x-1, p.y);
          case 4: if (even(p.y)) { return new Point(p.x-1, p.y-1); } else { return new Point(p.x, p.y-1); }
          case 5: if (even(p.y)) { return new Point(p.x, p.y-1); } else { return new Point(p.x+1, p.y-1); }
        }
        return null;
    }
    
    private boolean even(int i){
        return i%2==0;
    }
    
    public enum Colour{
        RED, BLACK
    }
    
    private Colour otherColour(Colour c){
        if (c==Colour.BLACK){
            return Colour.RED;
        }
        return Colour.BLACK;
    }
    
    private boolean rocky(Point p){
        return map.getCell(p).isRocky();
    }
    
    private int foodAt(Point p){
        return map.getCell(p).hasFood();
    }
    
    private void setFoodAt(Point p, int f){
        map.getCell(p).setHasFood(f);
    }
    
    private boolean anthillAt(Point p, Colour c){
        return map.getCell(p).getAnthill(c);
    }

    private void setMarkerAt(Point p, Colour c, int i){
        map.getCell(p).setMarker(i, true, c);
    }
    
    private void clearMarkerAt (Point p, Colour c, int i){
        map.getCell(p).setMarker(i, false, c);
    }
    
    private boolean checkMarkerAt(Point p, Colour c, int i){
        return map.getCell(p).getMarker(i, c);
    }
    
    private boolean checkAnyMarker(Point p, Colour c){
        boolean[] markers=map.getCell(p).getMarkers(c);
        for (int i=0; i<markers.length; i++){
            if (markers[i]){
                return true;
            }
        }
        return false;
    }
    
    
    private boolean cellMatches(Point p, Condition cond, Colour c){
        if(cond==Condition.ROCK){
            return rocky(p);
        }
        if(cond==Condition.FRIEND){
            return ((someAntIsAt(p))&&(colour(antAt(p))==c));
        }
        if(cond==Condition.FOE){
            return ((someAntIsAt(p))&&(colour(antAt(p))!=c));
        }
        if(cond==Condition.FRIENDWITHFOOD){
            return ((someAntIsAt(p))&&(colour(antAt(p))==c)&&(hasFood(antAt(p))));
        }
        if(cond==Condition.FOEWITHFOOD){
            return ((someAntIsAt(p))&&(colour(antAt(p))!=c)&&(hasFood(antAt(p))));
        }
        if(cond==Condition.FOOD){
            return foodAt(p)>0;
        }
        if(cond==Condition.MARKER){
            return checkMarkerAt(p, c, cond.markerNum);
        }
        if(cond==Condition.FOEMARKER){
            return checkAnyMarker(p, otherColour(c));
        }
        if(cond==Condition.HOME){
            return anthillAt(p, c);
        }
        if(cond==Condition.FOEHOME){
            return anthillAt(p, otherColour(c));
        }
        return false;
    }
    
    private Instruction getInstruction(Colour c, int s){
        if (c==Colour.RED){
            return redBrain.get(s);
        }
        return blackBrain.get(s);
    }
    
    private Colour colour(Ant a){
        return a.getColor();
    }
    
    private int adjacentAnts (Point p, Colour c){
        int n=0;
        for (int d=0; d<=5; d++){
            Point cell=adjacentCell(p, d);
            if (someAntIsAt(cell)&&colour(antAt(cell))==c){
                n++;
            }
        }
        return n;
    }
    
    private void checkForSurroundedAntAt(Point p){
        if (someAntIsAt(p)){
            Ant a = antAt(p);
            if (adjacentAnts(p, otherColour(colour(a)))>=5){
                if (hasFood(a)){
                    setFoodAt(p, (foodAt(p)+1));
                }
                killAntAt(p);
                setFoodAt(p, (foodAt(p)+3));
                statistics.mapFood+=3;
                if (anthillAt(p, Colour.BLACK)){
                    statistics.blackHillFood+=3;
                } else {
                    statistics.redHillFood+=3;
                }
            }
        }
    }
    
    private void checkForSurroundedAnts(Point p){
        checkForSurroundedAntAt(p);
        for (int d=0; d<=5; d++){
            checkForSurroundedAntAt(adjacentCell(p, d));
        }
    }
    
    private ArrayList<BigInteger> randomintS;
    
    private void initialiseRandomint(BigInteger seed){
        randomintS=new ArrayList();
        for (int i=0; i<4; i++){
            randomintS.add(BigInteger.ZERO);
        }
        randomintS.set(3, seed);
        for (int i=2; i>=0; i--){
            BigInteger news=randomintS.get(i+1);
            news=news.multiply(new BigInteger("22695477"));
            news=news.add(BigInteger.ONE);
            randomintS.set(i, news);
        }
    }
    
    private int randomint(int n){
        if (n<1){
            return 0;
        }
        randomintS.remove(3);
        BigInteger news=randomintS.get(0);
        news=news.multiply(new BigInteger("22695477"));
        news=news.add(BigInteger.ONE);
        randomintS.add(0, news);
        news=news.divide(new BigInteger("65536"));
        news=news.mod(new BigInteger("16384"));
        news=news.mod(new BigInteger(""+n));
        return news.intValue();
    }
    
    private int state(Ant a){
        return a.getState();
    }
    
    private int resting(Ant a){
        return a.getResting();
    }
    
    private int direction(Ant a){
        return a.getDirection();
    }
    
    private boolean hasFood(Ant a){
        return a.has_food();
    }
    
    private void setState(Ant a, int s){
        try {
            a.setState(s);
        } catch (Exception ex) {
            Logger.getLogger(Game.class.getName()).log(Level.SEVERE, null, ex);
        }//Should always work
    }
    
    private void setResting(Ant a, int s){
        a.setResting(s);
    }
    
    private void setDirection(Ant a, int d){
        try {
            a.setDirection(d);
        } catch (Exception ex) {
            Logger.getLogger(Game.class.getName()).log(Level.SEVERE, null, ex);
        }//Should always work
    }
    
    private void setHasFood(Ant a, boolean b){
        a.setHas_food(b);
        if (a.getColor()==Colour.BLACK){
            if (b){
                statistics.blackCarryFood++;
            } else {
                statistics.blackCarryFood--;
            }
        } else {
            if (b){
                statistics.redCarryFood++;
            } else {
                statistics.redCarryFood--;
            }
        }
    }
    
    private boolean someAntIsAt(Point p){
        if (p.x<0||p.x>=map.height||p.y<0||p.y>=map.width){
            return false;
        }
        for (Ant a:ants){
            if (a.getPosition()==p){
                return true;
            }
        }
        return false;
    }
    
    private Ant antAt(Point p){
        for (Ant a:ants){
            if (a.getPosition()==p){
                return a;
            }
        }
        return null;
    }
    
    private void setAntAt(Point p, Ant a){
        a.setPosition(p);
    }
    
    private void clearAntAt(Point p){
        antAt(p).setPosition(null);
    }
    
    private boolean antIsAlive(int id){
        return(!(ants.get(id).getPosition().equals(new Point(-1, -1))));
    }
    
    private Point findAnt(int id){
        return ants.get(id).getPosition();
    }
    
    private void killAntAt(Point p){
        Ant a=antAt(p);
        if(a.has_food()){
            setHasFood(a, false);
            setFoodAt(p, foodAt(p)+1);
            statistics.mapFood++;
        }
        a.setPosition(new Point(-1, -1));
        if(colour(antAt(p))==Colour.BLACK){
            statistics.blackAnts--;
            statistics.redKills++;
        } else {
            statistics.redAnts--;
            statistics.blackKills++;
        }
    }
    
    
    
    
    
}
